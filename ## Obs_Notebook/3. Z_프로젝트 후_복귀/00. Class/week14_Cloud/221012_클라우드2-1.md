***Searching***
NIC, crash(현상)
block storage, NAS->NFS, object storage, 
AWS -> S3
***
오후1) 

온프로미스 -> 직접 갖고 있는 것

AWS -> S3 (object storage)
- login 데이터 저장되는
- 버킷(bucket) 단위로 만들어짐
- ![[Pasted image 20221012145544.png]]
***빅데이터는 object storage를 쓰지는 못함

오후2)

1. 암호화
	1) 대칭키 암호
		- P (평문) --- E(알고리즘, Encryption),  P(평문)---> C (암호문)
		--> 암호화 : 알고리즘, 키(K1, 일련의 문자열)
		- P (평문) <--- E(알고리즘, Encryption),  P(평문)--- C (암호문)
		--> 복호화 : 암호키, 키(K2, 일련의 문자열)
		==K1 = K2 일 경우, 대칭키==
		==> S3, 받는 상대 모두 알고 있어야 (키분배 문제)
		==> 안전하게 전달하기 위해 ==> 공개키 암호 (K1, K2 분배)
		
	2) 공개키 암호
		- K1(공개키, 암호화할 때)
		- K2(개인키, 복호화할 떄 )
		- Alice            - Bob 예시 : 평문(A) -> 암호문(B)
		- 클라이언트 - 서버
		
     ==> 대칭키, 암호키 같이 씀 => SSL => 기반으로 한 것이 HTTP

 
	  RSA 알고리즘 - 속도가 느려짐 (용량을 1KB이하로 줄어야 함)
	   ex) 주민등록번호 관리를 했으나, 감사를 못함
	  DSA, ECC, 양자암호

	NPKI를 털어가면 공개키와 개인키를 다 쓸 수 있으니, 
	이를 예방하기 위해서, '암호를 묻는 것'
	-> '암호를 정하는 행위'는 개인키를 암호화하는 행위

	3) 해시 암호 (일방향 암호화)
		- 해시 : 무결성, 신뢰성 확인할 떄 쓰임
           - 길이 : 1024 ~ 2048
		- 평문을 해시에 넣으면, 어떤 것을 넣든 나오는 값의 길이는 정해져 있음
		 (고정길이의 압축값)
		 - 평문의 길이는 항상 해시보다 길다 => 압축함
		 - 평문으로 해시를 구하는 공식은 있음
		 - 해시로부터 평문을 구하는 공식은 없음 => 수많은 길이의 평문들을
		   동일한 알고리즘에 넣고 돌려 같은 값의 해시가 나오는 평문을 구함
           => 따라서, 일방향		   
		- 똑같은 해시값을 갖는 평문을 찾아 -> birthday paradox
		- 최소 23명이 있으면 50% 이상 (같은 생일자가 있는 경우)
			- 해) 해시의 길이를 늘려라


